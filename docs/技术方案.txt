基于大语言模型（LLM）的Google Chrome浏览器插件网页内容重排技术方案 V2.0

更新日期：2024年6月14日

执行摘要
本报告为一款利用大语言模型（LLM）动态重排网页静态内容的Google Chrome浏览器插件提供全面的技术方案。该插件的核心目标是通过智能整理信息、定制布局和移除冗余广告，显著提升用户的网页浏览体验。至关重要的是，所有重排操作必须严格遵守不影响网页原有按钮点击等交互功能的原则。

V2.0版本新增功能：
- 域名记忆系统升级：不仅保存用户需求，还保存具体修改命令，实现快速应用
- 历史记录功能：自动保存成功执行的重排需求，支持快速选择和载入
- 优化的存储架构：更高效的数据存储和检索机制
- 增强的用户体验：更直观的界面交互和历史管理功能

本方案详细阐述了符合Manifest V3规范的架构，包括利用内容脚本进行DOM交互、服务工作线程进行协调与LLM通信，以及用户友好的界面来捕获用户需求。关键策略涵盖识别和保护交互元素的鲁棒启发式方法和高级技术、用于精确DOM操作指令的结构化LLM输出，以及高效的DOM更新机制。

1. 引言
本节将为拟议的Chrome扩展程序奠定基础，详细阐述其旨在解决的问题、其愿景及其开发所遵循的基本目标和限制。

1.1. 问题陈述与愿景
问题： 现代网页普遍存在信息过载、布局不一致和广告泛滥的特点。这种“杂乱”的体验削弱了用户的专注度、生产力以及整体满意度。由于内容组织不佳和侵入性元素，用户难以高效地提取所需信息。

愿景： 旨在赋予用户个性化的浏览体验，使网页内容能够根据其特定需求和偏好进行智能重排和呈现。该扩展程序将充当一个智能代理，将混乱的网页转换为精简、以用户为中心的界面。

1.2. 拟议解决方案概述
该解决方案涉及一个Chrome扩展程序，它将内容脚本注入到活动网页中。该脚本将捕获页面的结构和内容，将其传输给LLM（无论是本地LLM还是通过API访问的LLM），并接收用于DOM操作的结构化指令。然后，这些指令将被执行，以重排静态元素、移除干扰并应用自定义布局，同时细致地避免干扰交互式组件。

1.3. 关键目标与限制
目标1：动态重排： 能够根据用户定义的标准实时重排静态HTML元素。

目标2：广告和杂乱内容移除： 有效识别并移除或隐藏不需要的广告和无关内容。

目标3：功能保留（关键限制）： 绝对确保交互元素（按钮、表单、链接、脚本）保持完全功能，不受重排影响。这对于用户体验和信任至关重要。

目标4：LLM集成： 无缝集成大语言模型以解释用户需求并生成精确的DOM操作指令。

目标5：性能： 在重排过程中保持响应迅速且流畅的浏览体验，将延迟降至最低。

目标6：安全性与隐私： 设计扩展程序时应具备强大的安全措施并优先考虑用户数据隐私。

2. Chrome扩展程序核心架构
本节详细介绍了Chrome扩展程序的基本组件，它们遵循Manifest V3标准，并解释了它们如何协同工作以实现所需功能。

2.1. Manifest V3结构与权限
每个Chrome扩展程序都必须在其根目录中包含一个manifest.json文件，该文件是扩展程序的“核心”或入口点，用于列出有关其结构和行为的重要信息 。对于此项目，   

manifest_version: 3是当前的标准版本 。   

manifest.json中的关键清单键包括name、version、description和icons，用于基本的识别和品牌展示 。   

action键定义了扩展程序在Google工具栏中的图标外观和行为，并可以链接到popup.html以实现用户交互 。   

background键指定了扩展程序的服务工作线程（service worker）脚本，该脚本充当事件处理程序 。   

权限是启用特定Chrome API的关键。activeTab权限在用户调用扩展程序（例如，点击图标）时，授予对当前活动标签页的临时主机权限。这对于内容脚本的程序化注入至关重要 。   

scripting权限是程序化注入内容脚本并在页面上执行JavaScript所必需的 。此外，如果希望直接“阻止”广告（如用户查询中“很多广告信息”所暗示），可以考虑使用   

declarativeNetRequest API，它允许在不通过内容脚本干预的情况下阻止和修改网络请求，从而提高性能和安全性 。   

在权限管理方面，Manifest V3明确要求列出所需的权限 。对于DOM操作，   

activeTab和scripting权限是不可或缺的 。然而，需要注意的是，像   

"<all_urls>"这样广泛的内容脚本权限通常会引起用户的疑虑，并可能增加扩展程序的攻击面 。因此，通过选择使用   

activeTab进行程序化注入 ，而不是使用广泛   

matches模式的静态内容脚本声明 ，扩展程序仅在用户明确调用时才在当前标签页上运行。这种设计与最小权限原则相符，增强了用户信任，并最大限度地减少了潜在的隐私问题，因为扩展程序的访问是临时的且由用户发起。   

在开发过程中，Manifest V3强制使用服务工作线程作为后台脚本 。当   

manifest、content scripts和服务工作线程文件发生更改时，需要手动在chrome://extensions中重新加载扩展程序 。这意味着任何对内容脚本注入方式、请求权限或后台服务工作线程事件处理方式的更改，都需要执行此重新加载步骤。这强调了模块化设计的重要性，其中核心架构组件应保持稳定，而快速迭代可以在不触发清单重新加载的内容脚本或UI组件中进行。   

Chrome扩展程序 Manifest V3 关键权限表

Manifest 键

值示例

描述

manifest_version

3

指定扩展程序使用的清单文件格式版本。

name

"网页重排LLM"

识别Chrome网上应用店、安装对话框和用户Chrome扩展程序页面中的扩展程序名称。

version

"1.0"

识别扩展程序的版本号。

description

"使用LLM根据用户需求重排网页内容。"

描述Chrome网上应用店和用户扩展程序管理页面中的扩展程序。

action

{ "default_popup": "popup.html", "default_title": "重排网页" }

定义扩展程序在Google工具栏中的图标外观和行为，并可链接到弹出窗口。

background

{ "service_worker": "background.js" }

指定包含扩展程序服务工作线程的JavaScript文件，该文件充当事件处理程序。

permissions

``

启用特定扩展程序API的使用。activeTab和scripting对于DOM操作至关重要；storage用于保存用户设置；declarativeNetRequest可用于广告拦截。

host_permissions

["<all_urls>"]

如果使用静态内容脚本或需要更广泛的API访问，则需要此项。但为了用户控制，通常优先使用activeTab。


导出到 Google 表格
2.2. 服务工作线程（后台脚本）
服务工作线程（background.js）是扩展程序的中央事件处理程序 。它在后台运行，可以访问所有Chrome扩展程序API 。至关重要的是，服务工作线程   

无法直接访问网页的DOM 。其作用是监听事件（例如，用户点击扩展程序图标，来自内容脚本的消息），协调逻辑，并与其他扩展程序部分进行通信。   

对于此扩展程序，服务工作线程将负责：

接收来自弹出窗口/侧边面板的用户输入/偏好设置。

启动内容脚本注入到活动标签页。

处理与LLM的通信（无论是客户端WebLLM还是远程API）。

处理LLM响应并将命令转发给内容脚本以供执行。

管理扩展程序状态和用户设置（例如，使用chrome.storage）。

服务工作线程无法直接与DOM交互 ，这意味着所有DOM操作逻辑   

必须委托给内容脚本。然而，服务工作线程可以访问所有WebExtension API 及其消息传递功能 ，这使其成为理想的协调器。这种设计模式促进了职责的清晰分离：服务工作线程处理高级逻辑、API调用和状态管理，而内容脚本则专门用于低级DOM交互。这种模块化设计提高了可维护性、可调试性和安全性，并通过限制每个组件的范围来降低风险。   

2.3. 内容脚本：DOM交互层
内容脚本是运行在网页上下文中的JavaScript文件 。它们是扩展程序中唯一能够直接读取和修改网页文档对象模型（DOM）的部分 。   

隔离世界： 内容脚本在“隔离世界”中运行，这意味着它们的JavaScript环境与网页本身的脚本是分离的 。这可以防止冲突，因为内容脚本无法直接查看或修改页面定义的JavaScript变量或函数，也无法看到页面脚本对内置DOM属性的重新定义 。   

内容脚本的“隔离世界”概念  是一把双刃剑。虽然它能防止与页面JavaScript的冲突，但也意味着内容脚本无法直接访问或理解页面的内部JavaScript状态或动态附加的事件监听器 。这对于“不要影响网页的按钮点击等功能”这一限制具有关键影响。扩展程序的DOM操作必须严格作用于静态元素的   

结构和样式，而不能更改或重新创建可能丢失其原始事件处理程序的交互元素。这强调了需要对交互元素进行鲁棒识别，以将其排除在重排之外。

通信： 内容脚本无法直接访问大多数Chrome API，但可以通过交换消息与服务工作线程（后台脚本）进行通信 。这种消息传递系统允许服务工作线程向内容脚本发送指令（例如，LLM生成的命令），内容脚本则可以发送回信息（例如，DOM快照、状态更新）。   

注入方法： 内容脚本可以通过多种方式注入 ：   

静态声明： 在manifest.json中通过matches模式定义，它们会在指定页面上自动运行 。这种方式由于应用范围广，不太适合按需重排。   

程序化注入： 使用scripting API（和activeTab权限），脚本可以在运行时注入到特定标签页中 。这是此扩展程序的首选方法，允许用户在当前页面触发重排。   

用户查询强调“根据我的需求”进行重排。静态声明的内容脚本  会在所有匹配的页面上运行，可能不必要地消耗资源。程序化注入 ，通过   

activeTab权限启用 ，允许内容脚本仅在用户明确触发扩展程序时（例如，点击工具栏图标）才运行。这为用户提供了何时何地进行重排的直接控制，通过避免在每次页面加载时都运行来提高性能，并符合用户对按需工具的期望。   

运行时间： 内容脚本的document_idle运行时间（静态声明的默认值）确保脚本在DOM完成加载后注入，但在图像等子资源完全加载之前 。这通常适用于DOM操作，因为此时结构已可用。   

2.4. 用户界面（弹出窗口/侧边面板）
扩展程序的用户界面将作为捕获用户偏好和启动重排的主要交互点。一个popup.html文件，通过manifest.json中的action键链接，是点击扩展程序图标时提供小型界面的标准方式 。或者，Chrome支持   

side_panel集成 ，它比瞬态弹出窗口提供更持久、功能更丰富的UI体验。   

用户请求中的“根据我的需求”意味着需要一种复杂的用户输入机制，而不仅仅是简单的“开/关”切换。一个设计良好的用户界面（弹出窗口或更优选的侧边面板）对于捕获这些细微的偏好至关重要。用户界面应允许用户不仅指定他们想要重排，还指定“如何”重排（例如，“极简主义”、“阅读模式”、“关注文本”）。这种动态输入将直接影响发送给LLM的提示，从而实现真正个性化的内容重排。侧边面板  提供更多屏幕空间，可用于复杂的控件和与LLM的持久聊天式交互。   

该用户界面将允许用户：

触发重排过程。

输入LLM的具体指令或偏好（例如，“总结主要内容”、“隐藏侧边栏”、“移除所有图片”）。

选择预定义的布局模板。

管理LLM设置（例如，API密钥、模型选择）。

2.5. 组件间通信
服务工作线程和内容脚本之间的通信是基础。由于它们在隔离环境中运行，因此无法直接进行函数调用。Chrome扩展程序为此提供了强大的消息传递API（chrome.runtime.sendMessage，chrome.runtime.onMessage） 。   

一次性消息： 适用于单个请求和响应（例如，服务工作线程请求DOM内容，内容脚本将其发送回去；服务工作线程发送LLM命令，内容脚本确认执行） 。   

长连接（端口）： 可用于多次消息交换，适用于流式LLM响应或持续更新 。   

消息传递系统  本质上意味着异步通信。服务工作线程发送消息并继续执行，等待响应。这需要仔细的状态管理。例如，服务工作线程可能需要跟踪请求来自哪个标签页，该标签页当前的重排状态是什么，并处理可能出现的竞态条件，如果发出了多个重排请求。在JavaScript中实现Promise或   

async/await模式对于管理这些异步流和确保组件之间可靠的数据交换至关重要。

3. 网页内容分析与元素识别
本节深入探讨了理解网页结构和内容的关键过程，特别关注区分静态元素和交互元素，以确保功能得到保留。

3.1. 捕获和处理网页DOM
内容脚本在网页上下文中运行，将捕获文档对象模型（DOM）。这涉及遍历DOM树并提取LLM的相关信息。将使用标准DOM操作方法来访问元素：

document.querySelector()和document.querySelectorAll()：使用CSS选择器选择元素的现代推荐方法 。   

document.getElementById()、getElementsByTagName()、getElementsByClassName()：也可用于特定的选择需求 。   

对于内容提取，element.textContent优于element.innerText，因为innerText通过检查计算样式强制回流，影响性能 。提取的信息应是页面内容的结构化表示，可能包括：   

段落、标题、列表的文本内容。

具有ID和类的结构元素（div、section、article）。

链接和图像的URL。

关键的是，标记已识别的交互元素（将它们排除在重排之外）。

LLM需要“理解”网页才能对其进行重排。发送原始的document.body.innerHTML通常过于冗长，包含不相关的数据（例如，隐藏元素、脚本标签），并且可能很快超出LLM的token限制 。因此，内容脚本中需要一个复杂的预处理步骤。这涉及创建DOM的   

语义快照：仅提取可见文本，识别结构元素（标题、段落、列表、主要内容区域），并捕获它们之间的关系，同时省略或明确标记交互元素。这种有针对性的输入减少了token数量，提高了LLM的处理效率，并指导LLM生成相关的重排命令 。   

3.2. 区分静态与交互元素的启发式方法
这是维护“功能保留”限制的关键方面。交互元素是为用户输入或操作而设计的元素，通常具有关联的JavaScript事件监听器。

HTML标签分析： 某些HTML元素本质上是交互式的或通常与交互性相关联 ：   

<button>：标准交互按钮 。   

<input>：各种交互式控件（文本、复选框、单选、提交等） 。   

<select>、<textarea>：表单输入元素 。   

<form>：交互式表单控件的容器 。   

<a>：超链接，触发导航 。   

带有onclick或其他on<event>属性的元素 。   

ARIA角色： WAI-ARIA（Web Accessibility Initiative - Accessible Rich Internet Applications）角色为元素提供语义含义，特别是对于辅助技术。许多ARIA角色明确指示交互性 ：   

小部件角色：button、checkbox、link、menuitem、radio、textbox、slider、switch、tab、treeitem、combobox、menu、tablist、tree、grid、listbox、radiogroup 。   

地标角色：form、search 。   

tabindex属性： tabindex属性决定元素是否可以通过键盘聚焦。tabindex="0"使不可聚焦元素可聚焦，tabindex="-1"允许程序化聚焦 。   

tabindex的存在强烈表明其预期的交互性。

虽然明确的HTML标签（<button>、<input>、<a>）和ARIA角色  是强有力的指示器，但一个简单的   

<div>也可以通过JavaScript变得可交互 。仅仅依靠预定义的标签列表或ARIA角色将不可避免地导致漏报（遗漏了仅是带有事件监听器的   

div的交互元素）。相反，范围过广（例如，将所有div都视为潜在交互）将严重限制重排能力。这需要一种多方面的方法，将标签分析与ARIA角色结合起来，理想情况下，还需要更高级（但具有挑战性）的方法，如事件监听器分析。其权衡在于完美检测与实际实现之间。

语义HTML元素和ARIA角色主要为可访问性而设计 。正确实现可访问性的元素通常具有内置的键盘导航功能，并被设计为可供所有用户交互 。这意味着，如果一个元素具有语义HTML标签（例如，   

<button>而不是<div role="button">）或特定的ARIA小部件角色，它极有可能具有交互性，并应被视为交互元素。这种启发式方法利用了良好的网页开发实践作为交互组件的信号。

识别交互式HTML元素的启发式方法表

类别

示例

描述/原因

动作

HTML标签

<button>, <input>, <select>, <textarea>, <form>, <a>

标准交互式控件，用于用户输入、提交或导航。

ARIA角色

role="button", role="link", role="checkbox", role="textbox", role="slider", role="switch", role="tab", role="menu" 等小部件角色；role="form", role="search" 等地标角色。

为辅助技术提供语义含义，指示元素具有交互功能。

属性

tabindex="0", onclick, onchange, onsubmit 等事件属性。

确定元素是否可通过键盘聚焦，或直接附加了JavaScript事件处理程序。

从LLM重排中排除，标记为不可变。


导出到 Google 表格
3.3. 高级检测：事件监听器分析
事件监听器是响应用户交互（例如，点击、悬停）的JavaScript函数 。事件监听器的存在是交互元素最明确的标志。   

挑战： JavaScript不提供标准的直接API来枚举附加到DOM节点的所有事件监听器 。   

变通方法（有注意事项）：

开发者工具： Chrome等浏览器在开发者工具中提供了“事件监听器”选项卡，用于检查所选元素上的监听器 。控制台命令   

getEventListeners($0)也可以检索它们 。这些仅用于调试，不能在扩展程序中进行程序化使用。   

“劫持”addEventListener： 一种程序化变通方法涉及覆盖Element.prototype.addEventListener以跟踪所有附加的监听器 。   

尽管“劫持”addEventListener技术  理论上允许程序化检测事件监听器，但其在生产Chrome扩展程序中的实际实现存在高度问题。它引入了显著的复杂性、潜在的性能开销，以及与页面自身脚本发生冲突的高风险，从而导致用户希望避免的功能中断。此外，浏览器更新很容易破坏这种脆弱的机制。鉴于“不影响网页的按钮点击等功能”的严格限制，更健壮、更安全的策略是严重依赖全面的启发式方法（HTML标签、ARIA角色、   

tabindex）来识别潜在的交互元素，然后明确指示LLM绝不修改这些已识别的元素或其直接的父/子元素。误报（将静态元素标记为交互式）的风险优于漏报（破坏关键交互元素）的风险。

3.4. 识别和过滤广告内容
用户明确提到“很多广告信息”是需要解决的问题。

传统方法： 广告拦截扩展程序通常使用预定义的黑名单（例如，EasyList）和declarativeNetRequest API来阻止已知广告域或资源的网络请求 。这种方法效率高，在内容加载之前在网络层面进行拦截。   

LLM的作用： 尽管LLM在生成广告文案和分析营销内容方面表现出色 ，但与传统方法相比，使用LLM进行实时、页面内广告   

检测以进行移除通常效率低下且计算成本高昂 。LLM理论上可以对文本进行“销售性”或“推广性”分类 ，但这需要将页面内容发送给LLM，从而产生延迟和成本。   

建议策略：

主要广告移除： 利用declarativeNetRequest  进行网络级广告拦截，或使用精选的CSS选择器来隐藏常见的广告容器。这是最有效和性能最佳的方法。   

LLM辅助的杂乱内容减少： LLM的主要作用应该是重排和内容摘要。可以提示LLM识别和最小化页面中“非必要”或“推广性”的部分（例如，侧边栏、推荐文章、传统方法未拦截的营销横幅），作为重排过程的一部分，而不是充当独立的广告拦截器。这将涉及指示LLM根据其内容和上下文识别类似广告的元素，然后建议隐藏它们（例如，通过LLM的输出命令设置display: none;）。

用户请求中提及的“广告信息”可以有两种解释：拦截广告，或者重排/隐藏类似广告的内容。传统的广告拦截（使用declarativeNetRequest ）经过高度优化，在网络层面进行，甚至阻止广告加载。使用LLM在页面上   

检测广告  将效率较低，引入延迟，并可能不必要地消耗LLM的token。LLM的优势在于   

理解和转换内容。因此，LLM的主要任务应该是重排剩余内容，并智能地识别传统广告拦截器可能未捕获的杂乱或推广部分，然后建议将其移除或重排。这是一种更有效的任务分工，LLM补充而非取代了既定的广告拦截技术。

4. 大语言模型（LLM）集成策略
LLM集成方式的选择（客户端或服务器端）将显著影响扩展程序的性能、隐私、成本和功能。本节将评估这两种方法。

4.1. 客户端LLM推理（例如，WebLLM，ONNX Runtime Web）
概念： 使用WebAssembly（WASM）和WebGPU等技术直接在浏览器中运行LLM 。   

框架：

WebLLM： 一个开源JavaScript框架，利用WebGPU进行GPU加速和WebAssembly进行CPU计算，实现在Web浏览器中高性能LLM推理 。它提供OpenAI风格的API以方便集成 。   

ONNX Runtime Web： 支持通过WebAssembly在浏览器中运行ONNX模型，包括大型模型 。   

优势：

隐私： 数据永不离开用户设备，确保完全隐私 。这与用户对“杂乱”信息的隐含隐私担忧高度契合。   

成本降低： 无需支付云服务相关的API费用 。   

离线能力： 无需互联网连接即可运行 。   

个性化： 能够利用本地数据实现高度个性化的AI模型 。   

性能考量与限制：

模型大小： 当前浏览器对ArrayBuffer（Chrome中约2GB）和WebAssembly内存（4GB）的限制，限制了可在客户端运行的模型大小 。虽然   

new WebAssembly.Memory()可以绕过2GB的ArrayBuffer限制，但它引入了其他限制 。这意味着通常只有较小的模型（例如，2-8亿参数）是可行的 。   

推理速度： 尽管WebLLM可以达到原生性能的80% ，但对于大型模型而言，推理速度仍可能慢于服务器端，尤其是在性能较低的硬件上 。   

早期开发阶段： WebLLM等技术仍处于早期开发阶段 ，这意味着可能存在错误或不完整的功能。   

资源密集型： LLM推理是计算密集型的 。使用Web Workers对于将计算从主UI线程卸载至关重要，以防止UI冻结 。   

客户端LLM提供了无与伦比的隐私和离线功能 。然而，这以模型大小和原始推理速度为代价，因为受到浏览器和硬件的限制 。用户对复杂重排的需求可能需要更强大（因此更大）的LLM。这直接带来了权衡：是优先考虑隐私和离线使用，但可能重排能力较弱，还是利用更大的云模型以获得更高级的功能，但牺牲隐私并产生费用。这种选择应明确呈现给用户，或设计为可配置项。   

LLM推理，即使是使用较小的模型，也具有计算密集性 。在主线程上执行此操作会阻塞浏览器UI，导致“卡顿”或无响应的体验 。Web Workers提供了一种在单独线程中运行JavaScript的机制，从而防止UI阻塞 。这是客户端LLM集成的一个关键架构决策，可确保页面重排过程不会对用户与浏览器交互的能力产生负面影响。   

4.2. 服务器端LLM API集成
概念： 将网页内容发送到远程LLM API（例如，OpenAI、Anthropic、Google Gemini，或自托管的服务器，如Ollama/LM Studio）进行处理 。   

优势：

模型规模与能力： 可以访问更大的、更强大的LLM（例如，GPT-4、Claude 3），这些模型无法在客户端运行 。这可能带来更细致和准确的重排效果。   

无本地硬件限制： 将计算卸载到强大的云GPU上 。   

更快的推理（对于大型模型）： 与当前的客户端能力相比，云基础设施可以为复杂模型提供更快的推理速度 。   

更容易更新： 模型更新在服务器端处理，无需更新扩展程序。

权衡：

隐私问题： 网页内容（可能包含敏感信息）必须发送到外部服务器 。这是一个显著的隐私影响。   

成本： 产生API使用费用 。   

延迟： 网络往返时间增加了重排过程的延迟 。   

依赖外部服务： 依赖于LLM提供商的可用性和稳定性 。   

API密钥管理： 需要安全处理API密钥 。   

与服务器端LLM集成需要处理API密钥 。这些密钥   

绝不能硬编码或在客户端JavaScript中暴露。它们应安全存储（例如，在用户输入后使用chrome.storage.sync，或如果由开发人员管理则通过安全代理） 。此外，发送到LLM的网页内容  可能包含个人身份信息（PII）或敏感数据。这需要在传输前进行仔细的数据清理，并获得用户明确的同意和数据处理透明度 。这是一个必须明确解决的关键隐私和安全问题。   

LLM集成方法比较表

特性

客户端（WebLLM/ONNX Runtime Web）

服务器端（API）

隐私

高（数据不离开设备）

低（数据离开设备）

性能（模型大小）

有限（2-4GB）

高（可支持大型模型）

性能（延迟）

较低（本地推理）

较高（网络往返）

成本

无

API费用

离线能力

是

否

设置/维护难度

较高（本地模型设置）

较低（API管理）

理想用例

个性化、隐私优先

复杂任务、可扩展性


导出到 Google 表格
4.3. 数据准备与传输至LLM
无论LLM集成策略如何，内容脚本都必须为LLM准备网页数据。这涉及从DOM中提取相关的、可见的内容，过滤掉不相关的元素（例如，脚本、隐藏元素），并将其结构化为干净、简洁的格式（例如，Markdown或简化的HTML字符串） 。   

至关重要的是，在第3.2节中识别的交互元素必须明确标记或完全从发送给LLM的数据中省略，并向LLM明确指示不要修改它们。LLM具有token限制，发送整个复杂网页的原始HTML效率低下且成本高昂 。内容脚本的作用是充当智能过滤器：仅提取   

语义相关和可见的内容，同时识别并明确标记交互且不应触碰的元素。这个预处理步骤对于优化LLM性能（更快的推理，更低的成本）和确保LLM专注于正确任务（重排静态内容）而不试图修改功能组件至关重要。这需要强大的解析和序列化逻辑。

5. LLM提示工程实现动态重排
扩展程序的有效性取决于LLM准确解释用户需求并生成精确、可执行的DOM操作命令的能力。本节详细介绍了构建有效提示和设计结构化输出的策略。

5.1. 编写有效提示实现布局转换
清晰指令： 提示必须明确说明所需结果和限制 。例如，“重排以下网页内容以提高可读性并消除干扰。重点关注文章主体文本。请勿修改任何按钮、输入字段或链接。”   

少量示例： 提供一些输入（原始HTML片段）和所需输出（结构化DOM命令）的示例，可以显著指导LLM生成特定的重排样式并遵守限制 。这比“零样本”提示对于复杂任务更有效。   

指定风格和语气： 指示LLM所需的审美或布局原则（例如，“极简主义”、“杂志风格”、“阅读模式”） 。   

分解复杂任务： 对于复杂的重排，将请求分解为提示中更小、按顺序的步骤（例如，“首先，识别主要内容区域。其次，移除所有侧边栏。第三，重新排序剩余部分以实现逻辑流程。”） 。   

上下文理解： 提示应包含网页的提取文本和结构上下文 。   

负面限制： 明确告知LLM不要做什么，特别是关于交互元素（例如，“不要触碰带有data-interactive='true'或任何<button>标签的元素。”）。

用户请求中“根据我的需求”的重排目标意味着LLM面临高度主观且复杂的任务。仅仅依靠简单的提示，初次尝试很可能无法令人满意。因此，此扩展程序的提示工程将是一个迭代过程 。它将涉及收集用户对重排的反馈，分析LLM输出失败（例如，功能中断、不理想的布局），并通过更具体的指令、限制和少量示例来优化提示 。这种持续优化对于实现高质量、可靠的重排至关重要。   

LLM不仅仅是生成文本，它被要求执行网页的空间和结构转换。这类似于一个“AI布局架构师”。因此，提示需要指导LLM不仅关注内容，还要关注结构关系和视觉层次。这要求LLM输出精确的、机器可执行的命令，这些命令可以转换为DOM操作。保留交互元素的关键限制意味着LLM必须明确“感知”这些元素及其边界，并被指示将其视为不可变区域。

5.2. DOM操作命令的结构化输出设计
为了使扩展程序可靠地执行LLM生成的重排，LLM的输出必须是结构化的，最好是JSON格式 。这允许程序化解析和执行。   

JSON Schema： 预定义的JSON schema将强制执行LLM输出的结构和类型 。这确保了一致性并减少了解析错误。   

命令类型： Schema应定义一组原子DOM操作动作：

move：相对于另一个元素重新定位一个元素。

selector：要移动元素的CSS选择器。

targetSelector：目标元素的CSS选择器。

position：before、after、prepend、append 。   

remove：从DOM中删除一个元素。

selector：要移除元素的CSS选择器 。   

hide：将元素设置为display: none!important;。

selector：要隐藏元素的CSS选择器 。   

style：将CSS属性应用于元素。

selector：要样式化元素的CSS选择器。

cssProperties：CSS规则的JSON对象（例如，{ "color": "white", "backgroundColor": "black" }） 。   

wrap：用新的HTML包裹现有元素。

selector：要包裹元素的CSS选择器。

wrapperHtml：用于包裹元素的HTML字符串（例如，<div class='new-container'>）。

reorderChildren：重排父元素内的子元素。

parentSelector：父元素的CSS选择器。

newOrder：所需顺序的子选择器/ID数组。

鲁棒选择器： 必须指示LLM使用鲁棒且唯一的CSS选择器（ID、特定类）来精确地定位元素，最大限度地减少歧义 。   

用户目标是“重新编排网页的静态代码元素”。这不是一个自由形式的文本生成任务。LLM的输出必须是JavaScript可直接执行的。因此，定义一个严格的JSON schema ，该schema概述了一组有限的精确DOM操作命令（例如，   

move、remove、hide、style、wrap）至关重要。这确保了LLM的输出不仅可供人类阅读，而且可供机器解析并直接执行，从而防止可能破坏页面的格式错误或模糊指令。该schema充当LLM与执行引擎之间的契约。

尽管有严格的schema，LLM偶尔仍可能生成格式错误或不符合规范的JSON 。因此，内容脚本必须包含一个鲁棒的验证步骤（例如，使用JSON Schema验证库），在尝试任何DOM操作之前，检查LLM的输出是否符合预定义的schema。如果输出无效，应将其丢弃并记录错误，或触发回退机制（例如，重新提示LLM，或使用“故障安全LLM”进行自动修复 ）。这可以防止扩展程序崩溃或由于LLM输出不正确而引入意外行为。   

LLM输出（DOM命令）示例 JSON Schema

JSON

{
  "type": "object",
  "properties": {
    "actions": {
      "type": "array",
      "description": "要执行的DOM操作列表。",
      "items": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["move", "remove", "hide", "style", "wrap", "reorderChildren"],
            "description": "操作类型。"
          },
          "selector": {
            "type": "string",
            "description": "要操作元素的CSS选择器。"
          },
          "targetSelector": {
            "type": "string",
            "description": "目标元素的CSS选择器（用于move/wrap操作）。"
          },
          "position": {
            "type": "string",
            "enum": ["before", "after", "prepend", "append"],
            "description": "相对于目标元素的位置（用于move操作）。"
          },
          "cssProperties": {
            "type": "object",
            "description": "用于'style'操作的CSS属性键值对。"
          },
          "wrapperHtml": {
            "type": "string",
            "description": "用于'wrap'操作的HTML字符串。"
          },
          "newOrder": {
            "type": "array",
            "items": { "type": "string" },
            "description": "子元素的新顺序（CSS选择器数组，用于reorderChildren操作）。"
          }
        },
        "required": ["type", "selector"],
        "oneOf": },
          { "properties": { "type": { "const": "wrap" } }, "required": ["wrapperHtml"] },
          { "properties": { "type": { "const": "style" } }, "required": ["cssProperties"] },
          { "properties": { "type": { "const": "reorderChildren" } }, "required": ["newOrder"] }
        ]
      }
    }
  },
  "required": ["actions"]
}
5.3. 融入用户偏好与上下文
用户的“需求”是重排的核心。这些偏好必须动态地融入LLM提示中。

用户配置文件/设置： 允许用户保存首选布局（例如，“阅读模式”、“开发者模式”、“极简视图”）或要优先/隐藏的特定内容类型。这些设置可以使用chrome.storage.sync进行跨设备同步存储。

动态提示构建： 服务工作线程将通过组合以下内容来构建LLM提示：

重排的基本指令。

当前网页的内容快照。

用户定义的偏好（例如，“隐藏所有侧边栏”、“优先处理文本内容而非图像”）。

明确的限制（例如，“不要触碰标识为X、Y、Z的交互元素”）。

上下文感知辅助： 可以提示LLM分析网页内容并提供上下文感知的重排建议，而不仅仅是盲目执行命令 。   

为了真正满足“根据我的需求”这一要求，LLM提示不能是静态的。它必须由扩展程序根据用户输入（来自UI）和当前网页的特定上下文动态构建。这意味着服务工作线程将充当“提示工程师”，获取用户偏好（例如，“隐藏广告”、“专注于文章文本”、“偏好简洁布局”）并将其与提取的DOM内容和一组不可变规则（例如，“不修改交互元素”）结合起来，形成对LLM的高度具体指令。这种动态提示是实现个性化和非破坏性重排的关键。

6. 动态DOM操作与功能保留
本节详细介绍了执行LLM生成命令的JavaScript实现策略，同时细致地保护网页的交互功能。

6.1. 执行LLM生成命令
一旦内容脚本从服务工作线程接收到验证过的JSON命令，它将遍历这些命令并应用相应的DOM操作。

元素选择： 使用document.querySelector()或document.querySelectorAll()根据LLM提供的CSS选择器可靠地选择目标元素 。   

应用更改：

移动元素： 使用Node.appendChild()、Node.insertBefore()或Element.insertAdjacentElement()来重新父化或重新排序元素 。   

移除元素： 使用Node.remove() 。   

隐藏元素： 修改element.style.display = 'none'或element.style.visibility = 'hidden' 。   

样式化元素： 直接修改element.style属性 。   

包裹元素： 使用document.createElement()创建新的包裹元素，然后使用Node.appendChild()或Element.insertAdjacentElement()插入并重新父化 。   

直接频繁的DOM操作可能计算成本高昂，导致布局抖动（回流和重绘）和“卡顿”的用户体验 。LLM可能会生成多个命令。为了缓解这种情况，内容脚本应尽可能批量处理DOM更新。例如，如果需要移除或重新父化多个元素，通常更有效的方法是将其从活动DOM中移除，在分离的片段或临时父元素上执行操作，然后一次性重新插入修改后的结构。这可以最大限度地减少浏览器重新计算布局的次数。   

6.2. 非破坏性静态元素重排策略
核心原则是修改呈现方式而不改变底层功能。

优先使用CSS进行隐藏/样式设置： 对于移除广告或不需要的内容，设置display: none!important;  或   

visibility: hidden;通常比从DOM中物理移除元素更安全、更少干扰 。这可以在DOM树中保留元素，避免页面脚本依赖其存在时可能出现的问题，即使元素被隐藏。   

重新父化而非重新创建： 在重排时，优先移动现有DOM节点（appendChild、insertBefore），而不是从头开始重新创建它们，因为重新创建可能会剥离原始页面脚本附加的事件监听器或数据。

最小化更改： 指示LLM提出实现所需布局所需的最小更改。

用户的问题陈述中包括“很多广告信息”和“不想要的布局”。虽然LLM可以建议移除元素 ，但对于非破坏性更改，通常更倾向于“隐藏”而非“删除”的方法。将元素设置为   

display: none!important;  是一种高性能  且非侵入性的方式，可以将元素从视觉流中移除，而不会改变原始页面JavaScript可能依赖的DOM结构。与彻底移除相比，这最大限度地降低了破坏功能的风险，特别是对于动态加载的内容或可能具有隐藏依赖关系的元素。   

6.3. 保护交互元素和事件监听器
这是最关键的限制：“注意这里不要影响网页的按钮点击等功能，仅仅是改变静态页面”。

不可变交互区域： 根据第3.2节中的启发式方法，识别所有被视为“交互式”的元素（按钮、输入框、链接、具有ARIA小部件角色、tabindex属性或onclick属性的元素）。

严格排除： LLM的提示必须明确指示它绝不生成以下命令：

针对这些已识别的交互元素进行remove、move、style（超出不影响交互的基本视觉调整）或wrap操作。

以可能破坏其布局或事件传播的方式修改已识别交互元素的直接父元素或子元素。

执行前验证： 在执行任何LLM生成的命令之前，内容脚本必须执行最终检查：如果命令针对已被识别为交互式元素（或其近亲），则应跳过该特定命令或将其标记为不安全。

隔离世界优势： 内容脚本的隔离世界可防止直接干扰页面的JavaScript变量或事件监听器实现 。这意味着扩展程序不会意外地重新定义页面的   

click处理程序。风险主要在于结构——移动/移除页面JavaScript期望在特定位置或存在的元素。

鉴于程序化枚举所有事件监听器  的难度以及保留功能的绝对必要性，最健壮的策略是定义“不可变交互区域”。这意味着一旦一个元素被识别为潜在交互式（使用HTML标签、ARIA角色和   

tabindex属性的组合），该元素及其直接的父元素和子元素，都将被标记为“禁止”进行任何LLM生成的结构修改。LLM的提示必须精心设计，以理解并尊重这一限制，并且内容脚本必须通过过滤掉任何违反这些规则的命令来强制执行。这种主动的保护措施比被动调试损坏的功能更可靠。

6.4. 处理动态内容变化（Mutation Observers）
现代网页具有高度动态性，内容可能异步加载或根据用户交互而变化（例如，无限滚动、单页应用程序）。

问题： 初始重排可能随着新内容的添加或现有内容被页面自身脚本修改而过时。

解决方案：MutationObserver： 此API允许内容脚本检测DOM中的变化 。   

配置MutationObserver以观察document.body或特定容器的childList（节点添加/移除）和subtree（后代内部变化） 。   

当观察到突变时，将触发回调函数。

重新应用策略： 检测到显著的DOM变化（例如，加载新内容）后，内容脚本可以：

重新评估新添加的DOM子树中的交互元素。

可能将新内容的局部DOM快照重新发送给LLM进行重排。

将LLM生成的新命令应用于动态添加的内容。

初始DOM快照的静态性质 [第3.1节] 对于动态网页来说是不够的。内容可以异步加载（例如，无限滚动、AJAX更新），使得初始重排过时或不完整。MutationObserver  是使扩展程序“实时”并适应变化的关键。通过持续监控DOM的变化，扩展程序可以对新内容做出反应，识别其中的交互元素，并应用重排规则。然而，这也引入了一个新的挑战：管理持续观察和潜在重新触发LLM调用的性能开销。重新应用策略必须高效，以避免性能螺旋。   

6.5. DOM更新的性能优化
高效的DOM操作对于流畅的用户体验至关重要。

最小化回流和重绘： 尽可能将多个DOM更改批量处理为单个操作 。例如，将元素从DOM中移除，执行修改，然后一次性重新插入它们。   

优先隐藏/显示： 如前所述，display: none;通常比创建/销毁元素更具性能优势 。   

使用insertAdjacentHTML： 对于插入HTML字符串，insertAdjacentHTML通常比innerHTML更快，因为它不会销毁和重新创建整个DOM子树 。   

document.createDocumentFragment： 对于复杂的多元素添加，在DocumentFragment（离线DOM）中构建结构，然后一次性添加该片段。

异步操作： 使用requestAnimationFrame进行视觉更新，以确保它们与浏览器的渲染周期同步。

Web Workers处理重型计算： 如第4.1节所述，LLM推理应在Web Worker中进行，以避免阻塞主线程 。   

从用户点击到页面重排的整个过程涉及多个步骤：DOM捕获、LLM调用（网络或本地推理）、LLM响应解析和DOM操作。每个步骤都会引入延迟。虽然Web Workers  可以处理LLM推理，但DOM操作本身必须高度优化 ，以最大限度地减少感知到的延迟。对于非常复杂的页面或较慢的LLM响应，提供即时视觉反馈（例如，微妙的覆盖层、一个“正在重排...”的消息）可以管理用户期望。一种“惰性重排”策略，即最初只处理可见视口，然后随着用户滚动逐步更新，也可以考虑用于超大型页面。   

7. 安全性、隐私和最佳实践
构建一个与网页内容和潜在外部AI服务交互的浏览器扩展程序，需要严格关注安全性和隐私。

7.1. 最小化权限和数据暴露
最小权限原则： 仅请求扩展程序运行所需的绝对最低权限 。如前所述，   

activeTab和scripting是核心权限，尽可能避免更广泛的host_permissions 。   

内容脚本隔离： 内容脚本的“隔离世界”  本身提供了一层安全性，可防止直接干扰页面的JavaScript上下文。   

避免eval()： 绝不要使用eval()或带有动态生成字符串的setTimeout()，因为这是跨站脚本（XSS）的主要安全漏洞 。解析JSON时始终使用   

JSON.parse() 。   

浏览器扩展程序本质上需要访问用户浏览数据。过于宽泛的权限可能会侵蚀用户信任并创建巨大的攻击面 。通过仔细选择仅必要的权限（如   

activeTab和scripting ）并解释其用途，扩展程序可以建立信任。这种透明度对于用户采纳至关重要，特别是对于修改网页内容的工具。   

7.2. 安全的LLM API密钥管理
如果使用服务器端LLM，则需要API密钥 。   

客户端存储（用户提供）： 如果用户提供自己的API密钥，应使用chrome.storage.sync（用于跨设备同步存储）或chrome.storage.local（用于本地存储）安全地存储这些密钥。这些存储区域是加密的，并且只能由扩展程序访问 。   

避免硬编码： 绝不将API密钥直接硬编码到扩展程序的源代码中。

代理服务器（开发人员管理）： 对于开发人员管理的密钥，应使用安全的后端代理。扩展程序将请求发送到此代理，然后代理在转发到LLM之前添加API密钥。这可以防止客户端暴露密钥。

API密钥的安全性至关重要，尤其是在与付费LLM服务交互时。硬编码密钥是一个严重漏洞。用户提供的密钥存储在chrome.storage中  与开发人员通过代理服务器管理的密钥之间，对安全性和用户体验都产生影响。用户提供的密钥将责任和成本转移给用户，而代理则集中管理，但引入了对开发人员基础设施的依赖。这两种方法都优先考虑不直接在客户端代码中暴露密钥。   

7.3. 防止跨站脚本（XSS）和恶意注入
LLM的输出如果直接解释为HTML，可能会引入XSS漏洞。

LLM输出的净化： LLM生成的任何HTML或JavaScript在插入DOM之前都必须经过严格的净化。这意味着：

优先使用DOM API而非innerHTML： 在操作内容时，尤其当内容是动态的或来自外部源时，使用document.createElement()、appendChild()、textContent  而不是   

element.innerHTML 。   

严格的JSON Schema： LLM的输出schema（第5.2节）应设计为生成明确的DOM命令（例如，move、remove、style），而不是任意HTML字符串，从而最大限度地降低注入风险。

内容安全策略（CSP）： 尽管对内容脚本操作现有DOM的直接适用性较低，但manifest.json中强大的CSP可以限制扩展程序自身可以加载和执行的资源。

LLM可能不可预测，如果它们的输出直接用于操作DOM，则存在恶意代码注入（XSS）的风险 。LLM可能会无意中生成   

<script>标签或javascript:URL。因此，严格的净化层是必不可少的。这不仅涉及解析LLM的JSON命令，还涉及仔细验证这些命令中的任何文本或HTML片段。优先使用不解析任意HTML的DOM操作方法（如textContent优于innerHTML ），并确保LLM被指示仅输出安全的结构化命令 [第5.2节]，是关键的安全保障措施。   

7.4. 用户数据隐私和同意
该扩展程序处理网页内容，其中可能包含敏感用户数据。

本地LLM优先： 积极推广和支持客户端LLM推理作为默认或首选选项，因为它具有固有的隐私优势（数据永不离开设备） 。   

明确同意云LLM： 如果使用基于云的LLM，扩展程序必须明确告知用户其网页内容将被发送到外部服务，并获得明确、知情的同意。提供禁用此功能或改用本地LLM的选项。

数据最小化： 仅将绝对必要的网页内容发送给LLM。过滤掉与重排无关的敏感信息（例如，表单输入值、Cookie、会话令牌）。

将网页内容发送到LLM，特别是基于云的LLM，构成数据共享 。鉴于公众对数据隐私日益增长的认识和关注，扩展程序必须对其数据处理实践保持透明。为用户提供在隐私保护的本地LLM和可能更强大的云LLM之间做出明确选择，是至关重要的。这种选择使得用户能够对数据共享拥有明确的控制权。   

结论与建议
本报告详细阐述了利用大语言模型（LLM）开发Google Chrome浏览器插件以实现网页内容重排的全面技术方案。核心挑战在于在提供个性化、去杂乱的浏览体验的同时，严格确保网页原有交互功能的完整性。

通过采用Manifest V3架构，并利用服务工作线程进行高级协调和内容脚本进行精确的DOM交互，该插件能够有效地捕获和重排网页的静态元素。识别交互元素的鲁棒启发式方法（基于HTML标签、ARIA角色和tabindex属性）是确保功能不被破坏的关键。虽然程序化事件监听器检测存在技术障碍和高风险，但通过将交互元素定义为“不可变区域”并严格限制LLM对其的修改，可以可靠地规避这些风险。

LLM集成方面，报告权衡了客户端（如WebLLM）和服务器端API两种模式。客户端LLM提供了卓越的隐私保护、成本效益和离线能力，但受限于模型大小和推理速度。相反，服务器端LLM可访问更强大、更复杂的模型，但涉及隐私风险、API成本和网络延迟。对于追求极致隐私和本地处理的用户，建议优先选择并优化客户端LLM，并利用Web Workers来保持UI的响应性。对于需要更高级重排能力的用户，则应明确告知服务器端LLM的数据隐私影响并获得其同意。

提示工程是该方案成功的核心。通过设计清晰、包含少量示例且具有负面限制的提示，LLM能够生成精确的、基于JSON Schema的DOM操作命令。这些命令（如move、remove、hide、style、wrap）将由内容脚本高效执行，同时通过批量处理DOM更新和优先使用CSS隐藏等策略来优化性能。MutationObserver的引入确保了插件能够适应动态加载的网页内容，持续提供一致的重排体验。

在安全性方面，最小权限原则、安全的API密钥管理（避免硬编码，推荐使用chrome.storage或代理服务器）以及对LLM输出的严格净化是防止XSS攻击和数据泄露的关键。透明地告知用户数据处理方式并提供选择，是建立用户信任和确保隐私合规性的基石。

建议：

分阶段开发： 优先实现核心的DOM捕获、启发式识别交互元素、LLM通信以及基于简单命令的静态内容重排功能。

LLM集成选择： 初始阶段可同时支持客户端和服务器端LLM，通过用户设置提供选择。大力投入客户端WebLLM的优化，以满足对隐私敏感的用户需求。

持续提示优化： 建立一个迭代的提示工程流程，根据用户反馈和实际网页重排效果不断优化LLM的提示和输出Schema。

鲁棒性与错误处理： 加强LLM输出的验证机制，并为DOM操作失败或LLM响应异常提供优雅的错误处理和回退方案。

性能监控： 实施详细的性能指标监控，特别是在DOM操作和LLM推理阶段，以识别瓶颈并持续优化用户体验。

通过遵循本报告中概述的详细技术方案和最佳实践，可以开发出一款功能强大、安全且以用户为中心的Chrome扩展程序，有效解决网页杂乱问题，并为用户提供高度个性化的浏览体验。

